/**
 * The MIT License (MIT)
 * Copyright (c) 2018 Devin Weaver
 *
 * Inspiration, R+D, and support graciously provided by FunnelCloud, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Version: 2.3.2
 */
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.confirmer = mod.exports;
  }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = _exports.CANCELLED = _exports.CONFIRMED = _exports.REJECTED = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var REJECTED = 'rejected';
  _exports.REJECTED = REJECTED;
  var CONFIRMED = 'confirmed';
  _exports.CONFIRMED = CONFIRMED;
  var CANCELLED = 'cancelled';
  _exports.CANCELLED = CANCELLED;

  function resolutionFor(reason, fn, promise) {
    return Confirmer.resolve(promise.then(function (result) {
      if (result.reason !== reason) {
        return result;
      }

      var newValue = fn(result.value);

      if (newValue instanceof Confirmer) {
        return newValue._promise;
      }

      return Confirmer.Promise.resolve(newValue).then(function (value) {
        return {
          reason: reason,
          value: value
        };
      });
    }));
  }

  var Confirmer = function () {
    function Confirmer(initFn) {
      _classCallCheck(this, Confirmer);

      var disposer = function disposer() {};

      if (!Confirmer.Promise) {
        throw new Error('You must provide a Promise implementation by assigning Confirmer.Promise');
      }

      this._promise = new Confirmer.Promise(function (resolve, reject) {
        initFn({
          error: reject,
          reject: function reject(value) {
            return resolve({
              reason: REJECTED,
              value: value
            });
          },
          confirm: function confirm(value) {
            return resolve({
              reason: CONFIRMED,
              value: value
            });
          },
          cancel: function cancel(value) {
            return resolve({
              reason: CANCELLED,
              value: value
            });
          },
          dispose: function dispose(fn) {
            return disposer = fn;
          }
        });
      }).then(function (result) {
        return Confirmer.Promise.resolve(disposer()).then(function () {
          return result;
        });
      }, function (error) {
        return Confirmer.Promise.resolve(disposer()).then(function () {
          throw error;
        });
      });
    }

    _createClass(Confirmer, [{
      key: "onConfirmed",
      value: function onConfirmed(fn) {
        return resolutionFor(CONFIRMED, fn, this._promise);
      }
    }, {
      key: "onRejected",
      value: function onRejected(fn) {
        return resolutionFor(REJECTED, fn, this._promise);
      }
    }, {
      key: "onCancelled",
      value: function onCancelled(fn) {
        return resolutionFor(CANCELLED, fn, this._promise);
      }
    }, {
      key: "onCanceled",
      value: function onCanceled(fn) {
        return this.onCancelled(fn);
      }
    }, {
      key: "onDone",
      value: function onDone(fn) {
        var promise = this._promise.then(function (result) {
          return Confirmer.Promise.resolve(fn()).then(function () {
            return result;
          });
        }, function (error) {
          return Confirmer.Promise.resolve(fn()).then(function () {
            throw error;
          });
        });

        return Confirmer.resolve(promise);
      }
    }, {
      key: "then",
      value: function then() {
        var _this$_promise;

        return (_this$_promise = this._promise).then.apply(_this$_promise, arguments);
      }
    }, {
      key: "catch",
      value: function _catch(fn) {
        return this._promise.then(null, fn);
      }
    }], [{
      key: "resolve",
      value: function resolve(result) {
        if (result instanceof Confirmer) {
          return result;
        }

        var newConfirmer = Object.create(Confirmer.prototype);
        newConfirmer._promise = Confirmer.Promise.resolve(result).then(function (result) {
          var reason = result && result.reason;

          if (![CONFIRMED, CANCELLED, REJECTED].includes(reason)) {
            throw new Error("Unknown resolution reason ".concat(reason));
          }

          return result;
        });
        return newConfirmer;
      }
    }]);

    return Confirmer;
  }();

  if (typeof Promise !== 'undefined' && Promise != null) {
    Confirmer.Promise = Promise;
  }

  var _default = Confirmer;
  _exports["default"] = _default;
});

